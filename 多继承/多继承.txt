多继承

------------------------

赋值兼容原则

不同类的对象一般不能互相赋值
但两个具有共有继承关系的对象可赋值

在公有派生下
任何使用基类对象的地方
都可以使用其派生类对象替代

允许赋值给间接基类

------------------
示例

class A{
public:
void f(){cout<<"A"<<endl;}
};

class B:public A{
public:
void f(){cout<<"B"<<endl;}
};

A a;
B b;
a=b;//将子类对象赋值给基类对象
//只将子类的基类成员部分赋值给基类对象
a.f();// A


//可以将b强制转换成A类型
//但是不会进行实际的赋值操作
（A）b=a;
b.f();

------------------------------

被赋值的基类对象只能访问基类的公有成员
不能访问派生类的公有成员

-----------------------

对象指针之间的互相赋值
不同类的对象的指针一般不能互相赋值

若指针指向的两个对象有公共继承关系

派生类对象指针（引用）可以赋值给
基类对象，反之不行

但是
可以使用强转将基类对象指针
显式转换成派生类的指针
来访问派生类的公有成员

会将基类扩展成子类
（（子类*）基类）->子类成员
但是数据成员没有被正确赋值
需要SET

---------------------------------

多重继承

class <派生类名>:<继承方式1><基类名1>，
                 <继承方式2><基类名2>，
                       .....{

};

--------------

构造函数
对继承成员初始化
对新加成员初始化

构造函数先执行基类的构造函数
有多个基类，按照定义的顺序构造
不是初始化列表的顺序

-------------

析构函数
析构不带参数
无需显式指明如何调用基类的析构函数
!!绝对不允许在子类中析构基类的指针


析构顺序与构造顺序相反

------------------------------

多重继承的二义性问题

两种解决问题
1.重写覆盖
  因为原则是先在子类寻找
  注意是覆盖而不是重载

2.使用作用域

--------------

重复继承

一个类只有完全定义才可以作为基类
无法直接或间接继承自己

不允许派生类直接重复继承基类两次

不允许直接或间接继承两次

允许菱形继承

-------------------

重复继承的二义性

解决方法

1.使用作用域

2.使用虚拟继承
（虚基类）
使得某个公共基类成员在派生类中
只产生一个拷贝

在重复继承时派生类的实例中
只储存一个副本

---------------------------

先执行带有虚基类的构造函数
再执行不含虚基类的构造函数
最后执行新加部分

注意构造函数需要添加间接虚基类的初始化

