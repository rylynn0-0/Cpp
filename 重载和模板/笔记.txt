#运算符重载（二）

----------------------------

##标准类型转换为类类型

1.通过自定义重载赋值运算符
2.构造函数

标准->类



void operator=(int i){
    	*this =A(i);
	}


---------------------------

##类转换成标准类型和类类型


需要提供以下成员函数

operator 类型名（）;

例：
operator int();
//将当前对象转换成int类型

没有返回值，参数值为空
最后需要返回 type类型的值

只能是非静态成员函数
因为需要this指针


operator （数值）type （）{}

可以实现 
类之间的大小比较
加减乘除



------------------------------

##I/O运算符重载


输出(输入）运算符重载
是一个二元运算符

<<第一个操作数是ostream对象
>>第一个操作数是istream对象


ostream & scout=cout；
scout<<n<<endl;

只能使用友元函数重载
返回值应该是ostream &
或者istream &

第二个参数必须是对象的引用

------------
输出
friend ostream &operator<<(ostream &stream,
                            const 类名&obj)
{//函数体
return stream;
}

----------
输入
friend ostream &operator>>(istream &stream,
                            类名&obj)
{//函数体
return stream;
}

-----------


可以实现输出+抽象类

----------------------------------------

##赋值运算符重载

只能作为类成员函数重载赋值运算
若对象内部数据不包括指针，无需重载

包含指针，需要重写拷贝构造函数
需要赋值运算符重载

---------------------------

##下标运算符重载

只能作为成员函数重载

提供向量安全访问的方法

--------------------------

##函数调用运算符重载

只能采用非静态成员函数

可以实现将类作为函数使用


--------------------------






#模板

程序复用最强大的方式

-------------------

概念

提出：
操作完全相同，类型不同
程序重复多

c++能将数据类型作为可变化
的数据的形参进行定义

-------------------------

函数模板

template<class T>
T Max (T x,T y){
return (x>y)x:y;
}

定义
在函数声明中
包含有参化数据类型的函数

-----------------------

函数模板的调用

编译器根据实参类型
自动确定模板实际参数类型

对函数模板进行实例化

与普通函数使用相同

------------------------


