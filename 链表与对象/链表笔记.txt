#链表#

频繁插入删除
大数据处理



##插入节点

不需要移动数据
头结点与其他位置同样处理
每个节点指向下个节点的地址

先new 一个新的节点
将指针移到要插入的前一个节点
将前一节点指向指向新节点
新节点指向下一节点

使用->访问next下一节点
要分清楚p的值和next的值

如果没有头结点
需要head指针指向第一个节点
头插入时新节点指向第一节点
head指针要改变指向

头结点数据可以用于计数n

当插入节点下标
小于1或大于n+1
需要return error
判断合法性

Node* head = new Node{0,NULL};
head是头指针，指向的Node才是头结点




##创建(头尾插入）链表

利用insertlist 循环插入（双循环）
不建议

#头插
new一个新节点，指向第一个节点
头结点指向新节点
头结点计数n++(如果需要

#尾插
new一个新节点,新节点指向NULL
让最后一个节点指向新节点
头结点计数n++（if need）

如果在函数内创建头结点需要return



##查询链表元素

判断i的合法性
i小于等于n，大于等于1
循环寻找数据
输出



##删除链表元素

不需要改数据空间

判断合法性
寻找该节点q
将前一节点next指向后一节点
delete q节点
头结点计数n--



##输出链表元素

判断p合法性
循环p=p->next
判断p是否为NULL
循环输出节点



##删除链表
定义一个指针指向head节点
循环while(head)
head=head->next;
delete p