#静态成员
所有类共用一个数据空间
描述这个类的对象的共有数据

声明在类外进行
数据初始化在类外执行
在main之前进行

静态成员与对象无关
只是对象可以访问静态成员

在编译时分配空间
程序结束才释放空间

静态数据不能缺省类外声明/初始化
静态数据可以是类

使用类做静态对象初始化
可以使用不带参数的构造函数

数据类型是私有的，
不能在类外引用


##静态数据成员常用场合

用来保存流动变化的对象个数

作为一个标志，指示特定动作是否发生

指向链表的的一个成员的指针



##静态成员函数

使用static声明的成员函数为静态成员函数

静态成员函数
不能访问非静态数据成员和非静态成员函数
只能访问静态成员和其他静态成员函数

静态成员函数作用是为了处理静态数据成员

静态成员函数可以
在不创建对象时使用


控制只能生成一个对象

class Sample{
	Sample(){x=0;}
	Sample(Sample&s){}
	int x;
	public:
		static Sample* GetObj(){
			static Sample* s=new Sample;
			return s;
		}
	void set(int i){x+=i;}
	void print(){cout<<x;}
};

int main(){
Sample *s1=Sample::GetObj();
s1->set(10);
Sample *s2=Sample::GetObj();
s2->set(20);
s1->print();
}




#友元

为了让类外的函数或另一个类
访问类中的私有成员
将其声明为友元

声明只能出现在类定义的内部

破坏了类的封装性和数据的安全性
提高效率


##友元函数
使得类外函数可以调用类的私有成员
简化操作，无需逐个写get函数


##复合类
需要声明两级


##一个类的成员函数作为另一个类的友元函数

函数来自A类，需要访问B类的私有成员
则在B类中 声明时：
friend void A::get();



##把整个类A作为类B的友元类，简称友元

则类B可以直接访问类A的所有私有成员


##友元类不具有交换性
友元关系是单向的

##友元关系不具有传递性

友元是非必要的
